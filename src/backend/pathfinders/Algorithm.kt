package backend.pathfinders

import backend.Node
import backend.World

/*
    The super class that all algorithms inherit from. It has the functions best path and find path defined as those methods
    will bethe same for all algorithms, the things that change are how the algorithms go about finding the cost table for the
    nodes that they are given. And the way that they go about updating the states of each node will vary depending on the
    algorithm so these are left are left to the child classes to implement.
*/
abstract class Algorithm(protected val world: World) {

    var open = mutableListOf(world.start!!)         // The adjacent nodes we have yet to look at in the algorithm
    var closed = mutableListOf<Node>()              // The nodes we have already looked at in the algorithm
    var isDone = false                              // The flag to let us know if the algorithm is done or a path is impossible
    var isImpossible = false                        // The flag to let us know if the algorithm is done due to an impossible path

    init {
        // Find all of the h values for the nodes in the world when we are created
        for (row in world.grid)
            for (node in row)
                world.calculateH(node, world.end!!)
        // Let the start node know it is on the frontier of the algorithm
        world.start?.onFrontier = true
    }

    abstract fun costMap(): HashMap<Double, Node>            // Method to return the map of costs for nodes as determined by each algorithm

    abstract fun updateNodes(node: Node)                     // Updates the states of each node for a given algorithm instance

    fun findPath() {
        // To get the best move we look at the map of costs generated by the algorithm and pick out the minimum cost
        val costs: HashMap<Double, Node> = costMap()
        val node = costs[costs.keys.minOrNull()]!!
        // We then update the node lists and set the flags accordingly
        updateNodes(node)
        isDone = world.end == node
        isImpossible = open.isEmpty()
    }

    fun bestPath(): MutableList<Node> {
        // We generate the best path by backtracking through the lowest cost moves back to the start node
        val path = mutableListOf(closed.last())
        while (path.last() != world.start!!)
            path.add(path.last().parent!!)
        return path
    }
}